import datetime as dt
import numpy as np
import pandas_datareader.data as web
import matplotlib.pyplot as plt
import pandas as pd
import yfinance as yf
import requests
from bs4 import BeautifulSoup as bs
from scipy.stats import kendalltau, pearsonr, spearmanr
import scipy.stats as stats
from statsmodels.distributions.empirical_distribution import ECDF
import seaborn as sns
import pandas as pd
from pycopula.copula import ArchimedeanCopula
import pycopula as pc
from statsmodels.tsa.stattools import adfuller
from statsmodels.tsa.stattools import coint
import statsmodels.api as sm


#------------------------------------------티커 리스트----------------------------------------------------------------#

def get_sp500_tickers():
    resp = requests.get('http://en.wikipedia.org/wiki/List_of_S%26P_500_companies')
    soup = bs(resp.text, 'lxml')
    table = soup.find('table', {'class': 'wikitable sortable'})
    tickers = []
    for row in table.findAll('tr')[1:]:
        ticker = row.findAll('td')[0].text
        tickers.append(ticker)

    return tickers

sp500tickers = get_sp500_tickers()

for i in range(0,504):
    sp500tickers[i] = sp500tickers[i][:-1]

sp500tickers.remove("AAPL")


#------------------------------------------------일별 데이터-------------------------------------------------------------


df = yf.download('AAPL',
                      period = '378d',
                      progress=False)
df= df['Close']
dfD = pd.DataFrame(df)
dfD.rename(columns = {'Close':'AAPL close'}, inplace = True)
dfDT = dfD.T

for ticker in sp500tickers:
    df_ = yf.download(ticker,
                      period = '378d',
                      progress=False)
    df_ = df_['Close']
    dfD_ = pd.DataFrame(df_)
    dfD_.rename(columns = {'Close': ticker+' '+'close'}, inplace = True)
    dfD_T = dfD_.T
    dfDT = dfDT.append(dfD_T)

data = dfDT.T

data.to_csv("C:/Users/나/Downloads/fulldata.csv", index= True)


#---------------------------------------로그 수익률 계산-------------------------------------------------------------------#

logreturn = np.log(data['AAPL close']/data['AAPL close'].shift(1))
logreturnDT = pd.DataFrame(logreturn).T

list = data.columns

for ticker in list:
    logreturn1 = np.log(data[ticker]/data[ticker].shift(1))
    logreturn1DT = pd.DataFrame(logreturn1).T
    logreturnDT = logreturnDT.append(logreturn1DT)

logreturn_data = logreturnDT.T
logreturn_data = logreturn_data.dropna(how = 'all')
#----------------------------------------------수익률--------------------------------------------------------------------

returns = 100 * data.iloc[:,[0]].pct_change().dropna()

for i in range(1,504):
    returns_ = 100 * data.iloc[:, [i]].pct_change().dropna()
    returns = pd.concat([returns,returns_], axis=1)

#-----------------------------------------------spear-man---------------------------------------------------------------

data_frame = pd.DataFrame([['' , '',]],
                   index=[''],
                   columns=['correlation', 'p-value'])

for i in range(1,505):
    for j in range(0,505):
        cor = stats.spearmanr(logreturn_data.iloc[:, [i]], logreturn_data.iloc[:, [j]])
        cor_data = pd.DataFrame(cor)
        cor_trans = cor_data.T
        cor_trans.columns = ['correlation' , 'p-value']
        cor_trans.index = [logreturn_data.columns[i] +' '+'&'+' '+ logreturn_data.columns[j]]
        data_frame = data_frame.append(cor_trans)

data_frame2 = pd.DataFrame([['' , '',]],
                   index=[''],
                   columns=['correlation', 'p-value'])

for i in range (1, 253512):                             #쓰지 않는 페어들
    if data_frame.iloc[i,1] > 0.005:
        Pv = data_frame.iloc[i:i+1]
        data_frame2 = data_frame2.append(Pv)

data_frame3 = pd.DataFrame([['' , '',]],
                   index=[''],
                   columns=['correlation', 'p-value'])

for i in range (1, 253512):                             #사용 될 페어들
    if data_frame.iloc[i,1] < 0.005:
        Pvv = data_frame.iloc[i:i+1]
        data_frame3 = data_frame3.append(Pvv)

data_frame4 = pd.DataFrame([['' , '',]],
                   index=[''],
                   columns=['correlation', 'p-value'])

for i in range(1,len(data_frame3)):
    if data_frame3.iloc[i,0] > 0.8:
        corrr = data_frame3.iloc[i:i+1]
        data_frame4 = data_frame4.append(corrr)

index1 = data_frame4[data_frame4['correlation'] == 1.0].index
index2 = data_frame4[data_frame4['correlation'] == 0.9999999999999999].index
data_frame4 = data_frame4.drop(index1)
data_frame4 = data_frame4.drop(index2)
data_frame4 = data_frame4.drop(data_frame4.index[0])
data_frame4 = data_frame4.sort_values(by=data_frame4.columns[0], ascending= False)
data_frame4 = data_frame4.iloc[::2]

top_15= data_frame4.iloc[:14]

stock_pairs = top_15.index.values.tolist()
pairs = []
for pair in stock_pairs:
    pairr = pair.split('&')
    pairs.append(pairr)

#----------------------------------------------------------수익률 cmle-----------------------------------------------------------

FOX = returns[['FOX close']]
FOXA = returns[['FOXA close']]
data1 = pd.concat([FOX, FOXA], axis = 1)
data2 = data1.to_numpy()

archimedean = ArchimedeanCopula(family="gumbel", dim=2)
result = archimedean.fit(data2, method="cmle")[0]

#---------------------------------------------로그수익률 cmle-------------------------------------------------------------

FOX_log = logreturn_data[['FOX close']]
FOXA_log = logreturn_data[['FOXA close']]
data3 = pd.concat([FOX_log, FOXA_log], axis = 1)
data4 = data1.to_numpy()

archimedean = ArchimedeanCopula(family="gumbel", dim=2)
result1 = archimedean.fit(data4, method="cmle")[0]

#-----------------------------------------------------------------------------------------------------------------------

#-------------------------------------------------mispricing index----------------------------------------------------------------

def _misprice_index(family, theta):
    '''Calculate mispricing index for every day in the trading period by using estimated copula
    Mispricing indices are the conditional probability P(U < u | V = v) and P(V < v | U = u)'''

    x = logreturn_data[[stock1]].values.tolist()
    y = logreturn_data[[stock2]].values.tolist()

    x = sum(x, [])
    y = sum(y, [])

    # Convert the two returns to uniform values u and v using the empirical distribution functions
    ecdf_x, ecdf_y = ECDF(x), ECDF(y)
    u, v = [ecdf_x(a) for a in x], [ecdf_y(a) for a in y]
    u = np.asarray(u)
    v = np.asarray(v)

    if family == 'clayton':
        MI_u_v = v ** (-theta - 1) * (u ** (-theta) + v ** (-theta) - 1) ** (-1 / theta - 1)  # P(U<u|V=v)
        MI_v_u = u ** (-theta - 1) * (u ** (-theta) + v ** (-theta) - 1) ** (-1 / theta - 1)  # P(V<v|U=u)

    elif family == 'frank':
        A = (np.exp(-theta * u) - 1) * (np.exp(-theta * v) - 1) + (np.exp(-theta * v) - 1)
        B = (np.exp(-theta * u) - 1) * (np.exp(-theta * v) - 1) + (np.exp(-theta * u) - 1)
        C = (np.exp(-theta * u) - 1) * (np.exp(-theta * v) - 1) + (np.exp(-theta) - 1)
        MI_u_v = B / C
        MI_v_u = A / C

    elif family == 'gumbel':
        A = (-np.log(u)) ** theta + (-np.log(v)) ** theta
        C_uv = np.exp(-A ** (1 / theta))  # C_uv is gumbel copula function C(u,v)
        MI_u_v = C_uv * (A ** ((1 - theta) / theta)) * (-np.log(v)) ** (theta - 1) * (1.0 / v)
        MI_v_u = C_uv * (A ** ((1 - theta) / theta)) * (-np.log(u)) ** (theta - 1) * (1.0 / u)

    return MI_u_v, MI_v_u

Position = logreturn_data.iloc[:,[0]]
df_posi2 = pd.DataFrame({'x':  range(378)})
df_posi = pd.DataFrame({'stock1': range(378),'stock1 position': range(378),'stock2': range(378),'stock2 position': range(378 ),'copula': range(378)})

pnl_dataframes = pd.DataFrame(np.zeros((378, 1)))

trading_size = 100

copulas = ['gumbel','frank','clayton']
for copula in copulas:
    for pair in pairs:
        stock1 = pair[0].strip()
        stock2 = pair[1].strip()

        x_ = logreturn_data[[stock1]]
        y_ = logreturn_data[[stock2]]
        xy = pd.concat([x_, y_], axis=1)
        data_ = xy.to_numpy()
        archimedean = ArchimedeanCopula(family=copula, dim=2)
        theta = archimedean.fit(data_, method="cmle")[0]
        MI_u_v, MI_v_u = _misprice_index(copula,theta)
        cap_CL = 0.95
        floor_CL = 0.05

        i = 0
        signal1 = 0
        signal2 = 0
        signal_list = []
        positions = pd.DataFrame([['', '', copula]],
                                 index=[''],
                                 columns=[stock1 + '' + 'position', stock2 + '' + 'postiton', 'copula'])
        pnl_dataframe = pd.DataFrame(np.zeros((378, 2)), columns=[stock1 + ' ' + '&' + ' ' + stock2 + ' '+'Pnl','copula' ])


        while i < len(MI_u_v):

            signal_list.append(str(signal1) + '&' + str(signal2))
            MI_u_v_num = MI_u_v[i]
            MI_v_u_num = MI_v_u[i]
            if signal1 == 0:
                if MI_u_v_num < floor_CL and MI_v_u_num > cap_CL:                   #u 매수 v 매도
                    signal1 = 'long'
                    signal2 = 'short'
                    pnl_dataframe.iloc[i, 0] = -trading_size * data[stock1][i] + trading_size * data[stock2][i]
                    pnl_dataframe.iloc[i, 1] = copula
                    df_posi.iloc[i, 0] = stock1
                    df_posi.iloc[i, 1] = signal1




                if MI_u_v_num > cap_CL and MI_v_u_num < floor_CL:
                    signal1 = 'short'
                    signal2 = 'long'
                    pnl_dataframe.iloc[i, 0] = trading_size * data[stock1][i] -trading_size * data[stock2][i]
                    pnl_dataframe.iloc[i, 1] = copula

            if signal1 == 'long':
                if (MI_v_u_num <= 0.5) and (MI_u_v_num >= 0.5):
                    signal1 = 0
                    signal2 = 0
                    pnl_dataframe.iloc[i, 0] = trading_size * data[stock1][i] - trading_size * data[stock2][i]
                    pnl_dataframe.iloc[i, 1] = copula


            if signal1 == 'short':
                if (MI_v_u_num >= 0.5) and (MI_u_v_num <= 0.5):
                    signal1 = 0
                    signal2 = 0
                    pnl_dataframe.iloc[i, 0] = -trading_size * data[stock1][i] + trading_size * data[stock2][i]
                    pnl_dataframe.iloc[i, 1] = copula

            df_posi.iloc[i, 0] = stock1
            df_posi.iloc[i, 1] = signal1
            df_posi.iloc[i, 2] = stock2
            df_posi.iloc[i, 3] = signal2
            df_posi.iloc[i, 4] = copula

            i = i + 1
            print(signal1)
            print(signal2)



        df_posi2 = pd.concat([df_posi2,df_posi], axis = 1 )
        pnl_dataframes = pd.concat([pnl_dataframes, pnl_dataframe], axis = 1)




cpnl = pnl_dataframes.iloc[:,[1]].cumsum()

for i in range(3,83,2):
    cpnl_ = pnl_dataframes.iloc[:,[i]].cumsum()
    cpnl =  pd.concat([cpnl,cpnl_], axis = 1)
